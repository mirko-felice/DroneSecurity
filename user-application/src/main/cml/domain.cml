ContextMap DroneManagementMap {
	type = SYSTEM_LANDSCAPE
	state = TO_BE
	contains DroneContext, IssueReportingContext, NegligenceReportingContext, ShippingContext, UserContext

	NegligenceReportingContext [U] -> [D, CF] DroneContext

	DroneContext [U] -> [D, CF] ShippingContext

    UserContext [U, OHS, PL] -> [D] ShippingContext

	UserContext [U, OHS, PL] -> [D] NegligenceReportingContext

	UserContext [U, OHS, PL] -> [D] IssueReportingContext
}

BoundedContext DroneContext implements Drone {
	type = FEATURE
	
	Aggregate Drone {
		ValueObject SensorData
		ValueObject Path
		
		Entity Sensor {
			- SensorData data
			
			def void activate();
			def void deactivate();
			def void isOn();
			def void readData();
			def SensorData getData();
		}
		
		Service DataAnalyzer {
			@AlertLevel checkDataAlertLevel(@SensorData sensorData);
		}

		Service DataProcessor {
		   Map<String, Integer> processAccelerometer(Map<String, Double> accelerometerData);
		}

		enum AlertLevel {
			STABLE, WARNING, CRITICAL;
		}

		enum DrivingMode {
            AUTOMATIC, MANUAL;
        }

		Entity Drone {
			String id
			- List<Sensor> sensors
			- DrivingMode drivingMode

			def void readAllData();
			def @SensorData getAllData();
			def void activate();
			def void deactivate();
			def void proceed();
			def void halt();
			def boolean isOperating();
			def void changeMode(@DrivingMode drivingMode);
		}
		
		Service DroneService {
			@Drone drone;
			DataAnalyzer dataAnalyzer;
			
			void waitForActivation();
			private void startDrone(@Path path_);
			private void stopDrone();
			
			private void publishData();
			private void publishAlert();
			private void publishCurrentStatus();
		}
	}
	
	Aggregate UserMonitoring {
		
		DomainEvent StatusChanged {
			String status
		}
		
		DomainEvent DataRead {
			- List<SensorData> sensorData
		}
		
		DomainEvent WarningSituation {
			String message
		}
		
		DomainEvent CriticalSituation {
			String message
		}
		
		Service UserMonitoringService {
			
			void subscribeToDataRead();
			void subscribeToAlerts();
			void subscribeToOrderStatusChange();
			List<DroneData> retrieveDataHistory(long orderId);
		}
	}
}

BoundedContext IssueReportingContext implements Reporting {
	type = FEATURE
	responsibilities "Drone Issues"
	Aggregate CourierReport {
		
		Entity IssueReport {
			String id
			- IssueMaintainer referenceMaintainer
		}
		
		DomainEvent NewIssue {
			- IssueReport report
		}

		Service CourierReportService {
			
			void reportsIssue(@IssueReport report);
		}
	}
	
	Aggregate MaintainerIssueReport {
		
		Entity FixForm {
			String id
		}
		
		Entity IssueMaintainer 
		
		Service MaintainerIssueReportService {
			
			void onNewIssue();
			void fillSolutionForm(@FixForm form);
		}
	}
}

BoundedContext NegligenceReportingContext implements Reporting {
	type = FEATURE
	responsibilities "Couriers' negligence"
	Aggregate DroneReport {
		
		Entity NegligenceReport {
			long orderId
			String negligent
			- DroneData data
			- Instant negligenceInstant
		}
		
		Service DroneReportService {
			
			void reportsNegligence(@NegligenceReport report);
		}
	}
	
	Aggregate NegligenceReporting {
		
		Entity NegligenceActionForm {
			String id
		}
		
		Entity NegligenceMaintainer

		DomainEvent NewNegligence {
            - NegligenceReport report
        }

		Service MaintainerNegligenceReportService {
			
			void subscribeToCourierNegligence(String courier);
			void takeAction(@NegligenceReport report, String solution);
			List<OpenNegligenceReport> retrieveOpenReportsForMaintainer(String username);
			List<ClosedNegligenceReport> retrieveClosedReportsForMaintainer(String username);
		}

		Service CourierNegligenceReportService {

		    void subscribeToNewNegligence();
		    void unsubscribeFromNewNegligence();
		    List<OpenNegligenceReport> retrieveOpenReportsForCourier(String username);
		    List<ClosedNegligenceReport> retrieveClosedReportsForCourier(String username);
		}
	}
}

BoundedContext ShippingContext implements Shipping {
	
	Aggregate Shipping {

		ValueObject OrderIdentifier
		ValueObject Product
		ValueObject OrderDate

		enum OrderState {
		    PLACED, DELIVERING, SUCCEEDED, FAILED, RESCHEDULED;
		}

		abstract Entity Order {
			aggregateRoot
			
			- OrderIdentifier id
			- Product product
			- OrderDate placingDate
			- OrderDate estimatedArrival
			- Client client
			
			Repository OrderRepository {
				List<@Order> listOrders();
				@Order retrieveOrderById(@OrderIdentifier orderId);
				@OrderIdentifier lastOrderIdentifier();
				void placed(@PlacedOrder order);
				void delivering(@DeliveringOrder order);
				void succeeded(@SucceededOrder order);
				void failed(@FailedOrder order);
				void rescheduled(@RescheduledOrder order);
			}
		}
		
		Entity PlacedOrder extends Order {
		    def void startDelivering(String droneId);
		}
		
		Entity DeliveringOrder extends Order {
		    def void succeedDelivery();
		    def void failDelivery();
		}
		
		Entity SucceededOrder extends Order
		
		Entity FailedOrder extends Order {
		    def void rescheduleDelivery(@OrderDate newEstimatedArrival);
		}
	
		Entity RescheduledOrder extends Order {
		    def @OrderDate getNewEstimatedArrival();
		}

		Service OrderManager {
		    List<@Order> listOrders();
            @Order retrieveOrderById(@OrderIdentifier identifier);
            void placeOrder(@PlacedOrder order);
		}

		Service DeliveryService {
		    void performDelivery(@PlacedOrder order, String droneId);
            void succeedDelivery(@DeliveringOrder order);
            void failDelivery(@DeliveringOrder order);
            void rescheduleDelivery(@FailedOrder order, @OrderDate newEstimatedArrival);
		}

		Service DroneController {
		    void callBack(@OrderIdentifier orderId);
            void changeDrivingMode(@OrderIdentifier orderId, @DrivingMode drivingMode);
            void proceed(@OrderIdentifier orderId);
            void halt(@OrderIdentifier orderId);
		}
	}
	
	Aggregate Client {

	    Entity Client
		
		ValueObject GPSPosition 
		
		DomainEvent ArrivalNotification
		DomainEvent RescheduleNotification
		
		Service ClientService {
			@Order placeOrder(@Product product);
			@GPSPosition track(@Order order);
			void onArrivalNotification();
			void onRescheduleNotification();
		}
	}
}

BoundedContext UserContext {

    Aggregate User {

        ValueObject Username

        enum Role {
            COURIER, MAINTAINER;
        }

        abstract Entity User {
            aggregateRoot

            def Username getUsername();
            def Role getRole();
            def boolean isLogged();
            def void logIn();
            def void logOut();

            Repository UserRepository {

                boolean isAuthenticated(@Username username, String password);
                void loggedIn(@User user);
                void loggedOut(@User user);
                @Courier retrieveCourierByUsername(@Username username);
                @Maintainer retrieveMaintainerByUsername(@Username username);
                Optional<@Role> checkLoggedUserRole();
                Optional<@Courier> retrieveLoggedCourierIfPresent();
                Optional<@Maintainer> retrieveLoggedMaintainerIfPresent();
            }
        }

        Entity Courier extends User {
            def @Username supervisor();
            def List<String> assignedDrones();
        }

        Entity Maintainer extends User

        Service AuthenticationService {
           boolean logIn(@Username username, String password);
           boolean logOut();
        }

        Service UserManager {
            @Courier retrieveCourierByUsername(@Username username);
            @Maintainer retrieveMaintainerByUsername(@Username username);
            Optional<@Role> checkLoggedUserRole();
            Optional<@Courier> retrieveLoggedCourierIfPresent();
            Optional<@Maintainer> retrieveLoggedMaintainerIfPresent();
        }
    }
}

Domain DroneSecurity {
	
	Subdomain Drone supports DataAnalysis, DataMonitoring, AccidentPrevention, WarningAlert {
		type = CORE_DOMAIN
		domainVisionStatement "Subdomain able to analyze sensor data and thus prevent accidents and/or warn about dangerous situations."
	}

	Subdomain Reporting supports NegligenceReporting, IssueReporting, FixManagement, NegligenceManagement {
		type = CORE_DOMAIN
		domainVisionStatement "Subdomain managing reports about drone issues and couriers' negligence."
	}

	Subdomain Shipping supports ArrivalNotification, Tracking, OrderPlacing, Shipping, DeliveryRescheduling {
		type = SUPPORTING_DOMAIN
		domainVisionStatement "Subdomain supporting everything related to the shipping process."
	}

	Subdomain User supports LogIn, LogOut {
	    type = SUPPORTING_DOMAIN
	    domainVisionStatement "Subdomain supporting user login and logout."
	}

}

UseCase DataAnalysis {
	actor "Drone"
	interactions
	"analyze" "sensor_data"
	benefit	"it can detect dangerous situations."
}

UseCase DataMonitoring {
	actor "Drone"
	interactions
	"sends" "sensor_data" for "Maintainer",
	"sends" "sensor_data" for "Courier"
	benefit "users can monitor the drone state."
}

UseCase NegligenceReporting {
	actor "Drone"
	interactions
	"reports" "negligence" for "Maintainer"
	benefit "Maintainer can takes action against the Courier negligence."
}

UseCase AccidentPrevention {
	actor "Drone"
	interactions
	"prevents" "accident"
	benefit "accident won't happen."
}

UseCase WarningAlert {
	actor "Drone"
	interactions
	"alerts" "Courier"
	benefit "the Courier can prevent accidents."
}

UseCase ArrivalNotification {
	actor "Drone"
	interactions
	"notify" "Client"
	benefit "Client will know that the product has arrived to destination."
}

UseCase Tracking {
	actor "Client"
	interactions
	"track" "Drone"
	benefit "Client can see Drone location."
}

UseCase OrderPlacing {
	actor "Client"
	interactions
	"place" "order"
	benefit "Client will receive the product."
}

UseCase IssueReporting {
	actor "Courier"
	interactions
	"reports" "issue" for "Maintainer"
	benefit "Maintainer can manage the issue."
}

UseCase Shipping {
	actor "Courier"
	interactions
	"perform" "delivery"
	benefit "Drone can deliver the product to Client."
}

UseCase DeliveryRescheduling {
	actor "Courier"
	interactions
	"reschedule" "delivery" for "Client"
	benefit "the product will be delivered another day."
}

UseCase FixManagement {
	actor "Maintainer"
	interactions
	"fill" "solution_form" for "Drone"
	benefit "the Drone can be fixed."
}

UseCase NegligenceManagement {
	actor "Maintainer"
	interactions
	"takes" "action" for "Courier"
	benefit "the Courier will be punished."
}

UseCase LogIn {
    actor "User"
    interactions
    "log" "in"
    benefit "he can use his functionalities."
}

UseCase LogOut {
    actor "User"
    interactions
    "log" "out"
    benefit "another user can log into the system."
}
